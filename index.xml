<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>In λ We Trust</title>
    <link>https://hinidu.github.io/index.xml</link>
    <description>Recent content on In λ We Trust</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 Feb 2017 11:41:30 +0200</lastBuildDate>
    <atom:link href="https://hinidu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Binary Search in Depth</title>
      <link>https://hinidu.github.io/post/binary-search-in-depth/</link>
      <pubDate>Sat, 11 Feb 2017 11:41:30 +0200</pubDate>
      
      <guid>https://hinidu.github.io/post/binary-search-in-depth/</guid>
      <description>

&lt;p&gt;This is the second post about &lt;em&gt;binary search&lt;/em&gt; algorithm. I suggest you to read
&lt;a href=&#34;https://hinidu.github.io/post/designing-binary-search/&#34;&gt;the first one&lt;/a&gt; if you didn&amp;rsquo;t do
it yet. In this post we&amp;rsquo;ll generalize &lt;em&gt;binary search&lt;/em&gt; to be able to find more
than just an element by its key.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our generalization lesson from the simpler example &amp;mdash; &lt;em&gt;linear
search&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;generalize-linear-search&#34;&gt;Generalize linear search&lt;/h2&gt;

&lt;h4 id=&#34;what-we-had-before&#34;&gt;What we had before?&lt;/h4&gt;

&lt;p&gt;I will put here the original version from &lt;a href=&#34;https://hinidu.github.io/post/designing-binary-search/&#34;&gt;the previous post&lt;/a&gt; for reference:&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;TElement LinearSearch&amp;lt;TElement, TKey&amp;gt;(
  IEnumerable&amp;lt;TElement&amp;gt; elements, Func&amp;lt;TElement, TKey&amp;gt; getKey, TKey key)
  where TKey : IEquatable&amp;lt;TKey&amp;gt;
{
  foreach (var element in elements)
    if (getKey(element).Equals(key))
      return element;
  return default(TElement);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(elements, get_key, key):
  for element in elements:
    if get_key(element) == key:
      return element
  return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- The simple version with explicit recursion for lists.
linearSearch :: Eq k =&amp;gt; (a -&amp;gt; k) -&amp;gt; [a] -&amp;gt; k -&amp;gt; Maybe a
linearSearch getKey (x:xs) k | getKey x == k = Just x
linearSearch getKey (_:xs) k                 = linearSearch getKey xs k
linearSearch _      []     _                 = Nothing

-- The generalized version with Monoid and Alternative magic for any Foldable 
-- data structure.
linearSearch&#39; :: (Foldable t, Eq k) =&amp;gt; (a -&amp;gt; k) -&amp;gt; k -&amp;gt; t a -&amp;gt; Maybe a
linearSearch&#39; getKey key =
  getAlt . foldMap (λx -&amp;gt; Alt $ if getKey x == key then Just x else Nothing)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;h4 id=&#34;new-challenge&#34;&gt;New challenge&lt;/h4&gt;

&lt;p&gt;But why do we constrain ourselves by hardcoding the desired property of an
element (the property of having some specific key)? Nothing can stop us from
searching for an element with any property that we want (let&amp;rsquo;s call this
property a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&#34;&gt;predicate&lt;/a&gt;):&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;TElement LinearSearch&amp;lt;TElement&amp;gt;(
  IEnumerable&amp;lt;TElement&amp;gt; elements, Func&amp;lt;TElement, bool&amp;gt; predicate)
{
  foreach (var element in elements)
    if (predicate(element))
      return element;
  return default(TElement);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(elements, predicate):
  for element in elements:
    if predicate(element):
      return element
  return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- The simple version with explicit recursion for lists.
linearSearch :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Maybe a
linearSearch predicate (x:_)  | predicate x = Just x
linearSearch predicate (_:xs)               = linearSearch predicate xs
linearSearch _         []                   = Nothing

-- The generalized version with Monoid and Alternative magic for any Foldable 
-- data structure.
linearSearch&#39; :: Foldable t =&amp;gt; (a -&amp;gt; Bool) -&amp;gt; t a -&amp;gt; Maybe a
linearSearch&#39; predicate =
  getAlt . foldMap (λx -&amp;gt; Alt $ if predicate x then Just x else Nothing)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;The code has became even simpler when we&amp;rsquo;ve forgot about all these cumbersome
keys and comparisons.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s how we can implement specific algorithm for searching by using the
generalized version of the algorithm:&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;LinearSearch(elements, x =&amp;gt; getKey(x) == key);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;linear_search(elements, lambda x: get_key(x) == key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;linearSearch (λx -&amp;gt; getKey x == key) xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;I&amp;rsquo;m sure you can imagine many more use cases for generalized algorithm and most
probably you use it almost every day &amp;mdash; many languages have something like
this in its standard library: C# has &lt;code&gt;elements.First(predicate)&lt;/code&gt;, Haskell has
&lt;code&gt;find predicate xs&lt;/code&gt;, though in Python you should combine two functions to get
the desired functionality &lt;code&gt;next(ifilter(predicate, elements), None)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Yeah, it was not very impressive. But I hope it will help us later with &lt;em&gt;binary
search&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;generalize-binary-search&#34;&gt;Generalize binary search&lt;/h2&gt;

&lt;h4 id=&#34;what-we-had-before-1&#34;&gt;What we had before?&lt;/h4&gt;

&lt;p&gt;Again I will put here the original version in pseudocode from &lt;a href=&#34;https://hinidu.github.io/post/designing-binary-search/&#34;&gt;the previous
post&lt;/a&gt; for reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function binary_search(a, n, k)
  l = -1
  r = n

  while r - l &amp;gt; 1
    m = (l + r) / 2
    if a[m] &amp;gt;= k
      r = m
    else
      l = m

  if r &amp;lt; n and a[r] = k
    return r
  else
    return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The major difference compared to &lt;em&gt;linear search&lt;/em&gt; is that we&amp;rsquo;ve modified the
required predicate: we check that &lt;code&gt;a[m] &amp;gt;= k&lt;/code&gt; instead of &lt;code&gt;a[m] = k&lt;/code&gt;. And we
check the strict equality only when we already found the first item in the
sequence that is greater than or equal to the specified key.&lt;/p&gt;

&lt;h4 id=&#34;mind-expansion&#34;&gt;Mind expansion&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s forget about original predicate for a moment &amp;mdash; if we omit the strict
comparison at the end of the algorithm then &lt;code&gt;r&lt;/code&gt; is the index of the &lt;strong&gt;first&lt;/strong&gt;
(and the &lt;strong&gt;smallest&lt;/strong&gt; too because the array is sorted) element in the array
that is &lt;strong&gt;equal to or bigger than k&lt;/strong&gt; (or &lt;code&gt;r = n&lt;/code&gt; if there is no such element).
By the way it can be useful sometimes to find such an element (if you want to
find the first deal since some date, the smallest price bigger than filter
specified by user, etc). Actually &lt;code&gt;lower_bound&lt;/code&gt; from C++ STL does exactly this.&lt;/p&gt;

&lt;p&gt;Now we can ask ourselves the same question as we did before with &lt;em&gt;linear
search&lt;/em&gt;: what&amp;rsquo;s special in &lt;code&gt;a[m] &amp;gt;= k&lt;/code&gt; predicate? Can we solve other problems
using the same algorithm? Of course we can! &lt;code&gt;upper_bound&lt;/code&gt; from C++ STL finds
the &lt;strong&gt;first&lt;/strong&gt; element &lt;strong&gt;bigger than k&lt;/strong&gt; and also implemented using &lt;em&gt;binary
search&lt;/em&gt; with predicate &lt;code&gt;a[m] &amp;gt; k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only real restriction is that the specified predicate should be &lt;code&gt;false&lt;/code&gt; for
zero or more initial values of the array and it should be &lt;code&gt;true&lt;/code&gt; for all values
after the falsy ones til the end of the array. For example we can have these
sequences of predicate results for &amp;ldquo;binary-searchable&amp;rdquo; array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;false false false true true true true
true true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But not these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;false true false true false true true
false true false
true true false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t want you to believe me &amp;mdash; if it&amp;rsquo;s not obvious to you why &lt;em&gt;binary
search&lt;/em&gt; impose this requirement on the data think about it more because the
understanding of this fact is very important for the proper usage of binary
search in practice. For example you can execute &lt;em&gt;binary search&lt;/em&gt; by hand with
bad inputs and see why it is possible to get a wrong answer.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;This is the pseudocode with &lt;code&gt;a[m] &amp;gt;= k&lt;/code&gt; replaced by predicate &lt;code&gt;p&lt;/code&gt;. And of
course there are updated implementations in real world programming languages:&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Pseudo&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function binary_search(p, a, n)
  l = -1
  r = n

  while r - l &amp;gt; 1
    m = (l + r) / 2
    if p(a[m])
      r = m
    else
      l = m

  if r &amp;lt; n
    return r
  else
    return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int? BinarySearch&amp;lt;TElement&amp;gt;(TElement[] elements, Func&amp;lt;TElement, bool&amp;gt; predicate)
{
  int l = -1, r = elements.Length;

  while (r - l &amp;gt; 1)
  {
    int m = (r + l) / 2;
    if (predicate(elements[m]))
      r = m;
    else
      l = m;
  }

  return r &amp;lt; elements.Length ? r : null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(elements, predicate):
  l = -1
  r = len(elements)

  while r - l &amp;gt; 1:
    m = (r + l) / 2
    if predicate(elements[m]):
      r = m
    else:
      l = m

  if r &amp;lt; len(elements):
    return r
  else:
    return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;binarySearch :: (IArray a e, Ix i, Integral i) =&amp;gt;
  (a -&amp;gt; Bool) -&amp;gt; a i e -&amp;gt; Maybe i
binarySearch predicate arr =
  let (l, r) = bounds arr
  in  loop (l - 1) (r + 1)
  where
    loop l r | r - l &amp;gt; 1 =
      let m = (l + r) `div` 2
      in  if predicate (arr ! m)
            then loop l m
            else loop m r

    loop _ r | bounds arr `inRange` r = Just r
             | otherwise = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;The code became simpler again (just like the code of &lt;em&gt;linear search&lt;/em&gt; above)
because we forget about insignificant details of specific predicate and write
only the core logic of the algorithm.&lt;/p&gt;

&lt;h4 id=&#34;next-step&#34;&gt;Next step?&lt;/h4&gt;

&lt;p&gt;Is it really everything we can squeeze out of &lt;em&gt;binary search&lt;/em&gt;? Can we make it
even more general? Of course yes!&lt;/p&gt;

&lt;p&gt;How we use the array in the algorithm? We just check a predicate on a handful
of its elements. What if we don&amp;rsquo;t have an array but the function &lt;code&gt;f&lt;/code&gt; to compute
them based on their indexes? It would be an awful waste to compute that array
only to run binary search on it. So we can replace hardcoded array by the
function that computes the elements of imaginary array by index.&lt;/p&gt;

&lt;p&gt;Also we should add the left boundary of the search space &lt;code&gt;left&lt;/code&gt; to the argument
list because now we don&amp;rsquo;t have an array that always start from 0 (though
Haskell arrays can have arbitrary boundaries and we already process them
correctly). Note that I&amp;rsquo;ve renamed &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;right&lt;/code&gt; to match the name of the new
&lt;code&gt;left&lt;/code&gt; argument. In memory of the forgotten array &lt;code&gt;a&lt;/code&gt; let&amp;rsquo;s assume that user
will provide the search range as a half-open interval &lt;code&gt;[left, right)&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Pseudo&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function binary_search(p, f, left, right)
  l = left - 1
  r = right

  while r - l &amp;gt; 1
    m = (l + r) / 2
    if p(f(m))
      r = m
    else
      l = m

  if r &amp;lt; right
    return r
  else
    return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int? BinarySearch&amp;lt;TElement&amp;gt;(
  Func&amp;lt;TElement, bool&amp;gt; predicate, Func&amp;lt;int, TElement&amp;gt; f, int left, int right)
{
  int l = left - 1, r = right;

  while (r - l &amp;gt; 1)
  {
    int m = (r + l) / 2;
    if (predicate(f(m)))
      r = m;
    else
      l = m;
  }

  return r &amp;lt; right ? r : null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(predicate, f, left, right):
  l = left - 1
  r = right

  while r - l &amp;gt; 1:
    m = (r + l) / 2
    if predicate(f(m)):
      r = m
    else:
      l = m

  if r &amp;lt; right:
    return r
  else:
    return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;binarySearch :: Integral i =&amp;gt; (i -&amp;gt; a) -&amp;gt; (i, i) -&amp;gt; (a -&amp;gt; Bool) -&amp;gt; Maybe i
binarySearch f (left, right) predicate = loop (left - 1) right
  where
    loop l r | r - l &amp;gt; 1 =
      let m = (l + r) `div` 2
      in  if predicate (f m)
            then loop l m
            else loop m r

    loop _ r | r &amp;lt; right = Just r
             | otherwise = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;h4 id=&#34;is-it-enough&#34;&gt;Is it enough?&lt;/h4&gt;

&lt;p&gt;Whew! We did a long path from &lt;em&gt;linear search&lt;/em&gt; to this very generic version of
&lt;em&gt;binary search&lt;/em&gt;. Do we still have some restrictions that we can break?
I encourage you to think about it a little bit yourself. Read the rest only
when you done it.&lt;/p&gt;

&lt;h4 id=&#34;one-last-step&#34;&gt;One last step&lt;/h4&gt;

&lt;p&gt;The last thing that we&amp;rsquo;ll mitigate is the type of elements in algorithm search
space &amp;mdash; there are a plenty of problems out there which can be solved using
&lt;em&gt;binary search&lt;/em&gt; but these problems are expressed using the function with real
number argument instead of an integer argument from the previous section.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how we should change the current implementation to work with real
numbers. Fortunately there is only one thing to change &amp;mdash; &lt;code&gt;while r - l &amp;gt; 1&lt;/code&gt;.
Of course in the real numbers setting we want more accurate answer (if we don&amp;rsquo;t
then why are we switching to real numbers in the first place?). Unfortunately
the way we should change it is quite tricky&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;ε-approach&#34;&gt;ε-approach&lt;/h5&gt;

&lt;p&gt;One thing that can come to your mind is that if we want better accuracy then we
can specify how much accuracy we want exactly. For example we could decide that
10&lt;sup&gt;-6&lt;/sup&gt; is enough for us so we&amp;rsquo;ll just write &lt;code&gt;while r - l &amp;gt; 1e-6&lt;/code&gt;. But
this approach can work or can not work &amp;mdash; it depends on your specific task.&lt;/p&gt;

&lt;p&gt;Why this approach can work is pretty obvious but why it can not work?  The
floating point number representation in computers is guilty.  The problem is
that standard floating point types have limited precision because there are
only 4, 8 or 16 bytes to represent the whole universe of real numbers. So the
real numbers in computer are countable. It means that we are in very strange
situation from the mathematical point of view &amp;mdash; in math between any pair of
real numbers exists another real number but this is not the case for floating
point arithmetic in computers. So we can say that every floating point number
have the &amp;ldquo;next&amp;rdquo; one. And the difference between the number and its &amp;ldquo;next&amp;rdquo;
number can be much more than our ε &amp;mdash; 10&lt;sup&gt;-6&lt;/sup&gt; (for example
10&lt;sup&gt;100&lt;/sup&gt; and it&amp;rsquo;s &amp;ldquo;next&amp;rdquo; number will sure have bigger difference).
I don&amp;rsquo;t want to describe representation of floating point numbers too deep so
if you didn&amp;rsquo;t understand this paragraph please read about &lt;a href=&#34;https://en.wikipedia.org/wiki/IEEE_floating_point&#34;&gt;IEEE floating
point&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The conclusion is that if we want to use the ε-approach we should take into
consideration possible result values and select actual value for ε accordingly.
So this approach is quite error-prone and I don&amp;rsquo;t recommend to use it unless
you fully understand what you&amp;rsquo;re doing &amp;mdash; because if you made a mistake you&amp;rsquo;ll
get an endless loop with some inputs.&lt;/p&gt;

&lt;p&gt;By the way this approach would work without endless loop problem for fixed
point arithmetic but floating point is much more common so I don&amp;rsquo;t describe it
in detail (though the world could be so much better place if fixed point
arithmetic was more widespread but unfortunately this world is cruel and full
of suffering).&lt;/p&gt;

&lt;p&gt;This approach is not ideal, let&amp;rsquo;s try to find something else.&lt;/p&gt;

&lt;h5 id=&#34;limited-iterations-approach&#34;&gt;Limited iterations approach&lt;/h5&gt;

&lt;p&gt;Maybe you already have a fix for ε-approach in your mind? How we can solve
endless-loop problem in general way? Let&amp;rsquo;s just limit the possible number of
iterations!&lt;/p&gt;

&lt;p&gt;Actually we can go even further and if we are too lazy to calculate the
required ε we can replace &lt;code&gt;while r - l &amp;gt; ε&lt;/code&gt; by &lt;code&gt;for iter from 1 to iter_count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now the only tricky question is that how many iterations you want to perform
&amp;mdash; you should find the balance between accuracy of the answer and performance.&lt;/p&gt;

&lt;p&gt;This approach is quite hacky, isn&amp;rsquo;t it? Can we be smarter?&lt;/p&gt;

&lt;h5 id=&#34;absolute-computational-accuracy&#34;&gt;Absolute computational accuracy&lt;/h5&gt;

&lt;p&gt;The answer is hiding again in floating point representation and the fact that
every floating point number have &amp;ldquo;neighbors&amp;rdquo; (the &amp;ldquo;next&amp;rdquo; number and the
&amp;ldquo;previous&amp;rdquo; one). Sooner or later &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; will become these &amp;ldquo;neighbors&amp;rdquo; and
in that case &lt;code&gt;(l + r) / 2&lt;/code&gt; will be equal to &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; and it will be not
possible to find more accurate answer for our problem with used floating point
type (that&amp;rsquo;s why I&amp;rsquo;ve named this method an &amp;ldquo;absolute computational accuracy&amp;rdquo;).&lt;/p&gt;

&lt;h4 id=&#34;finish&#34;&gt;Finish&lt;/h4&gt;

&lt;p&gt;That&amp;rsquo;s everything about generalization of &lt;em&gt;binary search&lt;/em&gt; that I can think
about. If you have any further ideas feel free to leave them in comments.&lt;/p&gt;

&lt;h2 id=&#34;advanced-usages&#34;&gt;Advanced usages&lt;/h2&gt;

&lt;p&gt;So now we are enlightened on the real essence of &lt;em&gt;binary search&lt;/em&gt;. But what we
can do with that? Let&amp;rsquo;s consider some examples.&lt;/p&gt;

&lt;h4 id=&#34;bug-hunting&#34;&gt;Bug hunting&lt;/h4&gt;

&lt;p&gt;The first example that comes to my mind is &lt;code&gt;git bisect&lt;/code&gt; (by the way &amp;ldquo;bisection&amp;rdquo;
is a mathematical name of &lt;em&gt;binary search&lt;/em&gt;). It&amp;rsquo;s a tool to find a commit that
has introduced some bug in your system. All commits are ordered and we have
a predicate &amp;ldquo;whether this bug is reproducible in current commit or not&amp;rdquo;. Almost
always this predicate will produce &lt;code&gt;false&lt;/code&gt; for some first commits and beginning
with the commit that has introduced that bug the predicate will return &lt;code&gt;true&lt;/code&gt;
til the end of the history. So if you know some commit without the bug you can
use that commit as a left boundary for &lt;em&gt;binary search&lt;/em&gt; and as a result you&amp;rsquo;ll
find the first commit with the bug.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt; will do all boring staff for you &amp;mdash; it only asks you whether
current commit has the bug or not and it stops when the first commit with the
bug was found.&lt;/p&gt;

&lt;p&gt;Of course if your SCM doesn&amp;rsquo;t have this feature you can do everything by hand
(or even write an analogue of &lt;code&gt;git bisect&lt;/code&gt; for your SCM).&lt;/p&gt;

&lt;h4 id=&#34;math&#34;&gt;Math&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Binary search&lt;/em&gt; can be used to calculate many math functions. The simplest
example is the &lt;code&gt;√x&lt;/code&gt; (actually we can do the same with roots of any degree) &amp;mdash;
the predicate is &lt;code&gt;m * m &amp;gt;= x&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;minimizing-costs&#34;&gt;Minimizing costs&lt;/h4&gt;

&lt;p&gt;I think that the biggest family of useful examples consists of the problems
where you know the method how to test that some value (length, size or amount
of anything) is enough to do something but you want to minimize the costs
hiding behind this value so you want to find the minimal value that is enough.
Now it should be pretty obvious how to solve such tasks using &lt;em&gt;binary search&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One of the hardest part in solving can be to formulate your problem in such
a way that is suitable for &lt;em&gt;binary search&lt;/em&gt;. You can find some of these problems
in the archives of
&lt;a href=&#34;https://www.topcoder.com/tc?module=ProblemArchive&amp;amp;sr=&amp;amp;er=&amp;amp;sc=&amp;amp;sd=&amp;amp;class=&amp;amp;cat=Search&amp;amp;div1l=&amp;amp;div2l=&amp;amp;mind1s=&amp;amp;mind2s=&amp;amp;maxd1s=&amp;amp;maxd2s=&amp;amp;wr=&#34;&gt;topcoder.com&lt;/a&gt;
and &lt;a href=&#34;http://codeforces.com/problemset/tags/binary%20search&#34;&gt;codeforces.com&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;post-scriptum&#34;&gt;Post Scriptum&lt;/h2&gt;

&lt;p&gt;I hope you&amp;rsquo;ve enjoyed the reading of this post and learned something new. Until
the next time!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Designing Binary Search</title>
      <link>https://hinidu.github.io/post/designing-binary-search/</link>
      <pubDate>Sat, 14 Jan 2017 14:37:28 +0200</pubDate>
      
      <guid>https://hinidu.github.io/post/designing-binary-search/</guid>
      <description>

&lt;p&gt;I would like to write about some useful algorithms which I have encountered in
my day to day job. I think that the most efficient and beneficial way of
learning algorithms is going through their design process step by step &amp;mdash; this
way you&amp;rsquo;ll get the solid understanding of how it works and most importantly the
skills to design algorithms yourself. I want to start from the most basic but
still powerful algorithm &amp;mdash; &lt;em&gt;binary search&lt;/em&gt;.  At first I will describe this
algorithm, then we will discuss it&amp;rsquo;s implementation tips and tricks, and in the
next post I will show you some extensions and advanced usages of this algorithm
(even the one you can use to find bugs in your programs).&lt;/p&gt;

&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;

&lt;h4 id=&#34;problem-statement&#34;&gt;Problem statement&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s talk about the most common usage of &lt;em&gt;binary search&lt;/em&gt; algorithm using
example from my current job. Our custom editor for MMORPG has many lists of
entities: mobs, items, quests, etc. Often we need to search for some entity by
some key (in our case it&amp;rsquo;s almost always entity ID). Most other applications
need to solve similar tasks.&lt;/p&gt;

&lt;h4 id=&#34;naive-solution&#34;&gt;Naive solution&lt;/h4&gt;

&lt;p&gt;The first solution that can come to mind is to look at each element in the
corresponding list comparing each element&amp;rsquo;s key with the needed one:&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;TElement LinearSearch&amp;lt;TElement, TKey&amp;gt;(
  IEnumerable&amp;lt;TElement&amp;gt; elements, Func&amp;lt;TElement, TKey&amp;gt; getKey, TKey key)
  where TKey : IEquatable&amp;lt;TKey&amp;gt;
{
  foreach (var element in elements)
    if (getKey(element).Equals(key))
      return element;
  return default(TElement);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def linear_search(elements, get_key, key):
  for element in elements:
    if get_key(element) == key:
      return element
  return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- The simple version with explicit recursion for lists.
linearSearch :: Eq k =&amp;gt; (a -&amp;gt; k) -&amp;gt; [a] -&amp;gt; k -&amp;gt; Maybe a
linearSearch getKey (x:xs) k | getKey x == k = Just x
linearSearch getKey (_:xs) k                 = linearSearch getKey xs k
linearSearch _      []     _                 = Nothing

-- The generalized version with Monoid and Alternative magic for any Foldable 
-- data structure.
linearSearch&#39; :: (Foldable t, Eq k) =&amp;gt; (a -&amp;gt; k) -&amp;gt; k -&amp;gt; t a -&amp;gt; Maybe a
linearSearch&#39; getKey key =
  getAlt . foldMap (λx -&amp;gt; Alt $ if getKey x == key then Just x else Nothing)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;Actually it&amp;rsquo;s a viable approach &amp;mdash; it&amp;rsquo;s dead simple, it works for any
traversable structure (arrays, linked lists, trees, graphs, etc) and it is
quite performant when there are only small number of elements. This algorithm
has its own name &amp;mdash; &lt;em&gt;linear search&lt;/em&gt;. As name suggests it&amp;rsquo;s execution time
depends on the number of elements &lt;strong&gt;linearly&lt;/strong&gt; in the worst case &amp;mdash; as you add
items to the list the execution time of this algorithm is growing
proportionally to the number of added items. Mathematically speaking &lt;em&gt;linear
search&lt;/em&gt; has &lt;a href=&#34;https://en.wikipedia.org/wiki/Time_complexity&#34;&gt;time complexity&lt;/a&gt;
&lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But we&amp;rsquo;re expecting quite big number of entities &amp;mdash; long-live MMORPG can have
thousands or even tens of thousands of quests, NPCs and items. And we need to
look for them in editor quite often because these entities are very
interconnected &amp;mdash; a quest can reference many other entities in the game world.&lt;br /&gt;
If we&amp;rsquo;ll scan the entire list to find the entity with required ID our users
(gamedesigners, artists and scriptwriters) will be very displeased by the
editor responsiveness and speed. Let&amp;rsquo;s think what we can do with it?&lt;/p&gt;

&lt;h2 id=&#34;algorithm-design&#34;&gt;Algorithm design&lt;/h2&gt;

&lt;h4 id=&#34;insight&#34;&gt;Insight&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s quite obvious that we can&amp;rsquo;t solve this problem faster if we don&amp;rsquo;t imply
some additional restrictions on the data &amp;mdash; required element can be anywhere
so in the worst case we should look at every element in the data structure.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try to remember good examples of solving &amp;ldquo;search by key&amp;rdquo; problem in the
real world. Some time ago people have actively used dictionaries and phonebooks
(now we successfully delegate these boring tasks to computers) and it would be
a real nightmare to search a word or a name in them if they were not sorted.
Maybe it&amp;rsquo;s still a good idea to sort the set to simplify the search?&lt;/p&gt;

&lt;h4 id=&#34;formalization&#34;&gt;Formalization&lt;/h4&gt;

&lt;p&gt;How exactly people used to optimize their search process in dictionaries and
phonebooks? Let&amp;rsquo;s analyze their behavior:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Choose some page.&lt;/li&gt;
&lt;li&gt;Check the content of the current page.&lt;/li&gt;
&lt;li&gt;If the current page contains the required word then the work is done!&lt;/li&gt;
&lt;li&gt;But if it&amp;rsquo;s not the case the person now have more useful information than it
had before &amp;mdash; by comparing the words on the current page and required word
we can determine whether the required word is on a page with a number less
than the current page&amp;rsquo;s number or it is on a page with a higher number.&lt;/li&gt;
&lt;li&gt;If the current page is the last candidate and we already know that no other
page can contain the required word then the search is completed though
unsuccessfully.&lt;/li&gt;
&lt;li&gt;Perform the same steps again but considering only the part of dictionary
which can contain the required word.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This way a person can significantly reduce the size of search set on each
iteration and avoid looking at each element of this set.&lt;/p&gt;

&lt;p&gt;But what&amp;rsquo;s the best way to choose the next page? If we will choose the first
remaining page at each iteration we will get exactly the &lt;em&gt;linear search&lt;/em&gt;
algorithm discussed above. At each iteration we want to exclude as many
elements as we can from our search set. By choosing some element for comparison
we split the search set into two parts &amp;mdash; the left part before choosen element
and the right one after it. But we don&amp;rsquo;t know which part will be excluded after
comparison so we should be prepared to each outcome and we can&amp;rsquo;t make
a preference to one of them. If we make one part significantly bigger than
another and if we&amp;rsquo;re not lucky then this bigger part remains. To avoid this
suboptimal situation we should make these parts&amp;rsquo; sizes as equal as possible.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s try to implement this algorithm step by step in pseudocode:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For simplicity (without loss of generality) let&amp;rsquo;s take the array of integers
&lt;code&gt;a&lt;/code&gt; with length &lt;code&gt;n&lt;/code&gt; (first index is &lt;code&gt;0&lt;/code&gt;).  In this array we&amp;rsquo;ll search for
integer &lt;code&gt;k&lt;/code&gt;.  Let&amp;rsquo;s define the search range as half-open interval &lt;code&gt;(l, r]&lt;/code&gt;
(&lt;code&gt;l&lt;/code&gt; is excluded, &lt;code&gt;r&lt;/code&gt; is included). To simplify the edge cases when &lt;code&gt;k&lt;/code&gt; is
less or greater than every element from &lt;code&gt;a&lt;/code&gt; we add two imaginary elements:
&lt;code&gt;a[-1] = -∞&lt;/code&gt; and &lt;code&gt;a[n] = +∞&lt;/code&gt;. They allow to use &lt;code&gt;(-1, n]&lt;/code&gt; as initial
boundaries and fulfill the invariant that &lt;code&gt;a[l] &amp;lt; k&lt;/code&gt; and &lt;code&gt;a[r] &amp;gt;= k&lt;/code&gt;. This
invariant will be useful in a proof of algorithm correctness.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;function binary_search(a, n, k)
  l = -1
  r = n
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;rsquo;s describe one step of searching. Take an item in the middle of the
current search range and compare it with &lt;code&gt;k&lt;/code&gt;. There are three possible cases:
selected element is less, equal or greater than &lt;code&gt;k&lt;/code&gt;. But we&amp;rsquo;ll combine two of
them to simplify our code. After comparison we should update search
boundaries accordingly.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;m = (l + r) / 2
if a[m] &amp;gt;= k
  r = m
else
  l = m
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;As you can see we maintain our invariant &lt;code&gt;a[l] &amp;lt; k&lt;/code&gt; and &lt;code&gt;a[r] &amp;gt;= k&lt;/code&gt;. So now
we should wrap this step in a loop. But when it should stop? &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;
become closer to each other and the size of search set becomes smaller after
each step.  Actually we should find the first element that is &lt;code&gt;&amp;gt;= k&lt;/code&gt;. So we
should stop when the search set contains no more than &lt;code&gt;1&lt;/code&gt; element (an edge
case with &lt;code&gt;n = 0&lt;/code&gt; will work as well).&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;while r - l &amp;gt; 1
  m = (l + r) / 2
  if a[m] &amp;gt;= k
    r = m
  else
    l = m
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Thoughtful reader could note that in the loop we&amp;rsquo;re accessing &lt;code&gt;a[m]&lt;/code&gt; but
there could be a problem if we try to access &lt;code&gt;a[-1]&lt;/code&gt; or &lt;code&gt;a[n]&lt;/code&gt; because they
exist only in our imagination. But we never access them &amp;mdash; if &lt;code&gt;r - l &amp;gt; 1&lt;/code&gt;
then &lt;code&gt;m != l&lt;/code&gt; and &lt;code&gt;m != r&lt;/code&gt; (there is always at least one integer number
between the two non-consecutive integer numbers).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We need just one step more to finish our algorithm. We&amp;rsquo;ve got &lt;code&gt;(l, r]&lt;/code&gt; search
boundaries where &lt;code&gt;l + 1 = r&lt;/code&gt;. Because we&amp;rsquo;ve maintained the invariant that
&lt;code&gt;a[l] &amp;lt; k&lt;/code&gt; and &lt;code&gt;a[r] &amp;gt;= k&lt;/code&gt;. So &lt;code&gt;a[r]&lt;/code&gt; is the smallest element of &lt;code&gt;a&lt;/code&gt; that is
&lt;code&gt;&amp;gt;= k&lt;/code&gt;. We just need to check whether it is a real element (not an imaginary
&lt;code&gt;a[n] = +∞&lt;/code&gt;) and whether it is &lt;code&gt;= k&lt;/code&gt; or not.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;if r &amp;lt; n and a[r] = k
  return r
else
  return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s the whole algorithm in pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function binary_search(a, n, k)
  l = -1
  r = n

  while r - l &amp;gt; 1
    m = (l + r) / 2
    if a[m] &amp;gt;= k
      r = m
    else
      l = m

  if r &amp;lt; n and a[r] = k
    return r
  else
    return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see it&amp;rsquo;s implementations with all bells and whistles of real world
programming languages:&lt;/p&gt;

&lt;div class=&#39;tabs-container&#39;&gt;
  &lt;ul class=&#34;tabs-menu&#34;&gt;&lt;/ul&gt;
  &lt;div class=&#34;tab-contents&#34;&gt;
    &lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;C#&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int? BinarySearch&amp;lt;TElement, TKey&amp;gt;(
  TElement[] elements, Func&amp;lt;TElement, TKey&amp;gt; getKey, TKey key)
  where TKey : IComparable&amp;lt;TKey&amp;gt;
{
  int l = -1, r = elements.Length;

  while (r - l &amp;gt; 1)
  {
    int m = (r + l) / 2;
    if (getKey(elements[m]).CompareTo(key) &amp;gt;= 0)
      r = m;
    else
      l = m;
  }

  return r &amp;lt; elements.Length &amp;amp;&amp;amp; getKey(elements[r]).CompareTo(key) == 0
    ? r
    : null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Python&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binary_search(elements, get_key, key):
  l = -1
  r = len(elements)

  while r - l &amp;gt; 1:
    m = (r + l) / 2
    if get_key(elements[m]) &amp;gt;= key:
      r = m
    else:
      l = m

  if r &amp;lt; len(elements) and get_key(elements[r]) == key:
    return r
  else:
    return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;tab-content&#34; title=&#34;Haskell&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;binarySearch :: (IArray a e, Ix i, Integral i, Ord k) =&amp;gt;
  (a -&amp;gt; k) -&amp;gt; a i e -&amp;gt; k -&amp;gt; Maybe i
binarySearch getKey arr key =
  let (l, r) = bounds arr
  in  loop (l - 1) (r + 1)
  where
    loop l r | r - l &amp;gt; 1 =
      let m = (l + r) `div` 2
      in  if getKey (arr ! m) &amp;gt;= key
            then loop l m
            else loop m r

    loop _ r | bounds arr `inRange` r &amp;amp;&amp;amp; getKey (arr ! r) == key = Just r
             | otherwise = Nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;


&lt;h2 id=&#34;algorithm-analysis&#34;&gt;Algorithm analysis&lt;/h2&gt;

&lt;h4 id=&#34;correctness&#34;&gt;Correctness&lt;/h4&gt;

&lt;p&gt;The most important part of correctness proof is the invariant that &lt;code&gt;a[l] &amp;lt; k&lt;/code&gt;
and &lt;code&gt;a[r] &amp;gt;= k&lt;/code&gt;. This invariant itself is pretty obvious to prove (it is true
before the loop, it is maintained on each iteration and it holds after the end
of the loop). You can try to prove it yourself to practice your formal
reasoning skills ;-) The small number of edge cases were described above as
well.&lt;/p&gt;

&lt;h4 id=&#34;performance&#34;&gt;Performance&lt;/h4&gt;

&lt;p&gt;Performance of &lt;em&gt;binary search&lt;/em&gt; can be measured by the amount of item lookups
and comparisons which the algorithm will do for an array of length &lt;code&gt;n&lt;/code&gt;. All
other operations are primitive and doesn&amp;rsquo;t add anything to the algorithm&amp;rsquo;s
&lt;a href=&#34;https://en.wikipedia.org/wiki/Time_complexity&#34;&gt;time complexity&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The number of lookups can be found using this recurrence relation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;T(0) = 0
T(n) = 1 + T(⌈n/2⌉)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution for this equation is &lt;code&gt;T(n) = O(log(n))&lt;/code&gt;. We divide &lt;code&gt;n&lt;/code&gt; by &lt;code&gt;2&lt;/code&gt;
until &lt;code&gt;n&lt;/code&gt; becomes &lt;code&gt;1&lt;/code&gt;. We should repeat division &lt;code&gt;log(n)&lt;/code&gt; times to achieve this
goal.&lt;/p&gt;

&lt;p&gt;So the time complexity of &lt;em&gt;binary search&lt;/em&gt; is
&lt;code&gt;O((LookupTime(n) + ComparisonTime) * log(n))&lt;/code&gt;.
In the case of integer array both &lt;code&gt;LookupTime(n)&lt;/code&gt; and &lt;code&gt;ComparisonTime&lt;/code&gt; are
&lt;code&gt;O(1)&lt;/code&gt; (constant) so in that case time complexity will be just &lt;code&gt;O(log(n))&lt;/code&gt;
which is significantly better than &lt;code&gt;O(n)&lt;/code&gt; of &lt;em&gt;linear search&lt;/em&gt;. You can think
about other data structures and key types &amp;mdash; what time complexity you&amp;rsquo;ll get
with them?&lt;/p&gt;

&lt;p&gt;Of course nothing comes for free &amp;mdash; we&amp;rsquo;ve constrained ourselves to sorted
arrays in opposite to the freedom of &lt;em&gt;linear search&lt;/em&gt;. Perhaps we&amp;rsquo;ll need to
sort the array before executing the &lt;em&gt;binary search&lt;/em&gt; or even maintain the order
of elements after additions, updates and deletions. So you should analyze
performance of your program in complex &amp;mdash; if you sort an array for only
&lt;strong&gt;one&lt;/strong&gt; execution of &lt;em&gt;binary search&lt;/em&gt; it&amp;rsquo;s just a waste of time because &lt;em&gt;sort&lt;/em&gt;
+ &lt;em&gt;binary search&lt;/em&gt; can&amp;rsquo;t be faster than &lt;em&gt;linear search&lt;/em&gt;. And if you need add,
update or delete elements frequently then &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_tree&#34;&gt;&lt;em&gt;binary search
tree&lt;/em&gt;&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table&#34;&gt;&lt;em&gt;hash
table&lt;/em&gt;&lt;/a&gt; would be a better fit.&lt;/p&gt;

&lt;h4 id=&#34;comparison-with-more-widespread-implementations&#34;&gt;Comparison with more widespread implementations&lt;/h4&gt;

&lt;p&gt;Perhaps you saw different implementations of &lt;em&gt;binary search&lt;/em&gt;. This one has
following peculiarities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fewer cases &amp;mdash; &lt;code&gt;a[m] &amp;lt; key&lt;/code&gt; and &lt;code&gt;a[m] &amp;gt;= key&lt;/code&gt; instead of classic &lt;code&gt;a[m] 
&amp;lt; key&lt;/code&gt;, &lt;code&gt;a[m] &amp;gt; key&lt;/code&gt; and &lt;code&gt;a[m] = key&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Imaginary &lt;code&gt;a[-1]&lt;/code&gt; and &lt;code&gt;a[n]&lt;/code&gt; elements.&lt;/li&gt;
&lt;li&gt;Half-open interval &lt;code&gt;(l, r]&lt;/code&gt; instead of closed interval &lt;code&gt;[l, r]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of it whill simplify the generalization of algorithm in the next post.&lt;/p&gt;

&lt;h2 id=&#34;to-be-continued&#34;&gt;To Be Continued&lt;/h2&gt;

&lt;p&gt;Thank you for reading! I hope it was useful and interesting for you. In the
next post I&amp;rsquo;ll describe more use cases and generalize &lt;em&gt;binary search&lt;/em&gt; to solve
broader set of problems than just searching for element in array.&lt;/p&gt;

&lt;p&gt;If you have any questions or suggestions feel free to leave a comment &amp;mdash;
I really appreciate any feedback.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello, blog!</title>
      <link>https://hinidu.github.io/post/hello-blog/</link>
      <pubDate>Wed, 28 Dec 2016 07:58:36 +0200</pubDate>
      
      <guid>https://hinidu.github.io/post/hello-blog/</guid>
      <description>

&lt;h2 id=&#34;brief-history-of-failures&#34;&gt;Brief history of failures&lt;/h2&gt;

&lt;p&gt;I was tempted to start my blog so many times before. But I had two kind of
problems which was stopping me:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I didn&amp;rsquo;t know what&amp;rsquo;s interesting I can write.&lt;/li&gt;
&lt;li&gt;It was hard to choose the blogging platform which meets all my needs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;why-now&#34;&gt;Why now?&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s discuss why these problems didn&amp;rsquo;t stop me this time:&lt;/p&gt;

&lt;h4 id=&#34;i-hope-i-m-not-so-boring-anyway&#34;&gt;I hope I&amp;rsquo;m not so boring anyway ;-)&lt;/h4&gt;

&lt;p&gt;Recently I&amp;rsquo;ve started to think that some of the discussions with my colleagues
or some of the stories about different open source and work projects can be
useful and/or interesting to someone else. Also I can get some value myself
from writing the blog thanks to your future insightful comments and more
thorough research on posts&amp;rsquo; topics (because I need to understand something very
well to explain it to somebody).&lt;/p&gt;

&lt;h4 id=&#34;the-first-step-is-the-hardest-one&#34;&gt;The first step is the hardest one&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m a geek and I like simple text tools much more than fancy GUI apps which
I don&amp;rsquo;t understand and/or control enough to feel myself comfortable.&lt;/p&gt;

&lt;p&gt;So I was inclined to the static site generators from the first time I thought
about blogging. There are another two reasons why I didn&amp;rsquo;t start to use one
them before:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I don&amp;rsquo;t want to deal with the dependency hell of the big projects
implemented in interpreted languages, i.e. &lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;
or &lt;a href=&#34;http://octopress.org/&#34;&gt;Octopress&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;m not very experienced with HTML/CSS/JS so I was afraid that it will be
too hard for me to make my blog visually appealing.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m a Haskell enthusiast so my favorite option for the very long time was
&lt;a href=&#34;https://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt;. But it had no themes to choose from so
I never actually tried to write something real with it.&lt;/p&gt;

&lt;p&gt;But lately I&amp;rsquo;ve heard about quite popular &lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt; site
generator written in Go. I&amp;rsquo;ve watched &lt;a href=&#34;https://www.youtube.com/watch?v=w7Ft2ymGmfc&#34;&gt;A New Hugo Site in Under
2 Minutes&lt;/a&gt; and I was really
amazed! It is very straightforward to use and install (just one static binary
with zero dependencies). And it has more than a 100
&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;themes&lt;/a&gt; to choose from!&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So if you are in a similar position to what I was before I encourage to give
Hugo a chance!&lt;/p&gt;

&lt;h4 id=&#34;p-s&#34;&gt;P.S.&lt;/h4&gt;

&lt;p&gt;I hope to write some stuff soon so stay tuned and thank you for reading!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>